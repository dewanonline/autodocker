#!/usr/bin/env node
const R            = require('ramda')
const port         = require('portastic')
const debug        = R.memoize(require('debug'))
const fs           = require('fs')
const { execSync } = require('child_process')
const _spawn       = require('child_process').spawn

const {
  repositories, timeout, workdir, portastic
} = require('./config')

const getFreePorts = () => port.find(portastic)

const exec = (...args) => {
  debug('exec')(...args)
  let result = String(execSync(...args))
  if (result) debug('exec:stdout')(result)
  return result
}

const spawn = (args, {cwd} = {cwd: '.'}) => {
  return new Promise((resolve, reject) => {
    let [command, ..._args] = R.split(' ', args)
    debug('spawn')(args, cwd)
    let process = _spawn(command, _args)
    process.stdout.on('data', (data)=>debug(`spawn:stdout:${args}`)("\n" + String(data)))
    process.stderr.on('data', (data)=>debug(`spawn:stderr:${args}`)("\n" + String(data)))
    process.on('close', (code) => resolve(code))
  }).catch(console.error)
}

const createWorkDir = () =>
  exec(`ls ${workdir} 1>/dev/null ||\n mkdir ${workdir}`)

const cloneRepoIfNotExists = ({path, cwd}) =>
  exec(`ls ${cwd} 1>/dev/null ||\n git clone --depth 1 ${path} ${cwd}`)

const parseStdout = R.compose(R.reject(R.isEmpty), R.split('\n'), String)
const removeSelectedBranch = R.map(R.replace(/^\*\s+/,''))
const removeOrigin = R.map(R.replace(/^\s+origin\//,''))
const removeHEAD = R.reject(R.test(/HEAD/))
  
const getRemoteBranchesHEAD = (cwd) =>
  removeOrigin(removeHEAD(parseStdout(exec("git branch -r -v --no-color", {cwd}))))
  
const getLocalBranchesHEAD = (cwd) =>
  removeSelectedBranch(parseStdout(exec("git branch -v --no-color", {cwd})))

const getNotUpdatedRefs = (cwd) =>
  getRemoteBranchesHEAD(cwd)
  // R.difference(getRemoteBranchesHEAD(cwd), getLocalBranchesHEAD(cwd))
  
const updateBranches = (cwd) => exec("git fetch -a", {cwd})

const runImageOnPort = R.curry((image, cwd, port) => {
  let [fromPort, ...ports] = exposedPorts(fs.readFileSync(`${cwd}/Dockerfile`))
  spawn(`docker run --name ${image} ${image} -p ${port}:${fromPort} -d`)
})

const exposedPorts = R.compose(R.flatten, R.map(R.match(/\d+/g)), R.match(/expose.*/gi))

const buildBranches = ({cwd, refs, name}) =>
  Promise.all(R.map(ref => {
    let [branch, commit, ...message] = R.split(' ',ref)
    message = message.join(' ')
    let image = `${name}-${branch}`
    debug("branch")(branch, commit, message)
    
    exec(`git checkout ${branch}`)
    exec(`git pull`)
    runImageOnPort(image, 8000)
    return spawn(`docker build --tag ${image} .`)
      .then(getFreePorts)
      .then(R.head)
      .then(runImageOnPort(image, cwd))
      .catch(debug('docker:error'))
  }, refs))

const processRepos = R.mapObjIndexed((path, name) => {
  const cwd = [workdir,name].join('/')
  cloneRepoIfNotExists({path, cwd})
  buildBranches({cwd, name, refs: getNotUpdatedRefs(cwd)})
})

createWorkDir()
processRepos(repositories)

const tick = () => {
    
}
setTimeout(tick, timeout)
